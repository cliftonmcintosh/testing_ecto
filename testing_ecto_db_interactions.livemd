# Testing Ecto Schema

```elixir
Mix.install(
  [
    {:testing_ecto, path: Path.join(__DIR__, "."), env: :test}
  ],
  config_path: :testing_ecto,
  lockfile: :testing_ecto
)
```

## Introduction

### What to test

Don't test the framework.

Test that your code uses the framework correctly.

Heuristic: you _should not_ test that a function in Ecto works correctly, but you should test that it is _called_ correctly.

## Testing Your Schema Through Changesets

### A sample module for testing

* Uses an embedded schema because we aren't yet testing the database
* Uses reflection in the `all_fields/0` function to get a list of fields for casting

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule TestingEcto.Schemas.UserBasicSchema do
  use Ecto.Schema

  import Ecto.Changeset

  @optional_fields [:favorite_number]

  @primary_key false
  embedded_schema do
    field(:date_of_birth, :date)
    field(:email, :string)
    field(:favorite_number, :float)
    field(:first_name, :string)
    field(:last_name, :string)
    field(:phone_number, :string)
  end

  defp all_fields do
    __MODULE__.__schema__(:fields)
  end

  def changeset(params) do
    %__MODULE__{}
    |> cast(params, all_fields())
    |> validate_required(all_fields() -- @optional_fields)
  end
end
```

#### Sample tests

Some tests that test if we are using Ecto Schema correctly

1. The presence of fields in a schema
2. Casting input
3. Validating input

## Start ExUnit

```elixir
ExUnit.start(autorun: false)
```

<!-- livebook:{"branch_parent_index":2} -->

## Happy path with valid arguments

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidArgumentsTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      params = %{
        "date_of_birth" => "1948-02-28",
        "email" => "example@example.com",
        "favorite_number" => 3.14,
        "first_name" => "Bob",
        "last_name" => "Matthews",
        "phone_number" => "555-555-5555"
      }

      changeset = UserBasicSchema.changeset(params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for field <- @schema_fields, field not in mutated do
        actual = Map.get(changes, field)
        expected = params[Atom.to_string(field)]

        assert actual == expected,
               "Values did not match for field: #{field}\nexpected: #{inspect(expected)}\nactual: #{inspect(actual)}"
      end

      expected_dob = Date.from_iso8601!(params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end
  end
end

ExUnit.run()
```

## Testing casting

#### Avoid brittle tests

A test that checked to see **how many errors** are generated would be brittle.

A test that checks to make sure you get the **right kind of error** would not be brittle.

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaCastingTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "error: returns an error changeset when given un-castable values" do
      not_a_string = DateTime.utc_now()

      # invalid params for each field
      params = %{
        "date_of_birth" => "not a date",
        "email" => not_a_string,
        "favorite_number" => "not a number",
        "first_name" => not_a_string,
        "last_name" => not_a_string,
        "phone_number" => not_a_string
      }

      changeset = UserBasicSchema.changeset(params)

      assert %Changeset{valid?: false, errors: errors} = changeset

      for field <- @schema_fields do
        assert errors[field], "expected an error for #{field}"
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end
  end
end

ExUnit.run()
```

## Testing schema validation

An example of a useful test for validation would be a test that checks to make sure that required fields are included.

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidateRequiredFieldsTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "error: returns error changeset when required fields are missing" do
      # Empty map to force violation of the validation for required fields
      # A nil or empty string would also fail validation for a required field
      params = %{}

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(params)

      optional_params = [:favorite_number]
      expected_fields = @schema_fields -- optional_params

      for field <- expected_fields do
        assert errors[field], "Field #{inspect(field)} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :required,
               "The validation type, #{meta[:validation]}, is incorrect."
      end

      for field <- optional_params do
        refute errors[field],
               "The optional field #{field} is required when it shouldn't be."
      end
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Refactoring to Increase Test Maintainability

Refactoring tests to be "self-updating"

Goes through several steps to improve test maintainability

1. Validating field types in a schema
2. Adding helper functions to generate valid and invalid data

## Tests for validating types in a schema

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidatingFieldTypesTest do
  use ExUnit.Case

  alias TestingEcto.Schemas.UserBasicSchema

  # Adds tuples that allow testing of fields and their types
  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "fields and types" do
    @tag :schema_definition
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserBasicSchema.__schema__(:fields) do
          type = UserBasicSchema.__schema__(:type, field)
          {field, type}
        end

      assert MapSet.new(actual_fields_with_types) ==
               MapSet.new(@expected_fields_with_types)
    end
  end
end

ExUnit.run()
```

## Generating data in a test

Adding a helper function to generate valid data for fields testing

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidParamsHelperTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      valid_params = valid_params(@expected_fields_with_types)

      changeset = UserBasicSchema.changeset(valid_params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for {field, _} <- @expected_fields_with_types, field not in mutated do
        actual = Map.get(changes, field)
        expected = valid_params[Atom.to_string(field)]

        assert actual == expected,
               "Values did not match for field: #{field}\nexpected: #{inspect(expected)}\nactual: #{inspect(actual)}"
      end

      expected_dob = Date.from_iso8601!(valid_params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end
  end

  defp valid_params(fields_with_types) do
    valid_value_by_type = %{
      date: fn -> to_string(Faker.Date.date_of_birth()) end,
      float: fn -> :rand.uniform() * 10 end,
      string: fn -> Faker.Lorem.word() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), valid_value_by_type[type].()}
    end
  end
end

ExUnit.run()
```

## Testing Invalid Params

Adding a helper function to generate invalid data for fields testing

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaInvalidParamsHelperTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "changeset/1" do
    test "error: returns an error changeset when given un-castable values" do
      invalid_params = invalid_params(@expected_fields_with_types)

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(invalid_params)

      for {field, _} <- @expected_fields_with_types do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end
  end

  defp invalid_params(fields_with_types) do
    invalid_value_by_type = %{
      date: fn -> Faker.Lorem.word() end,
      float: fn -> Faker.Lorem.word() end,
      string: fn -> DateTime.utc_now() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), invalid_value_by_type[type].()}
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Creating a SchemaCase for Shared Test Code

### Functions that can be useful in more than one test module moved to a `Case` module

Functions for generating valid and invalid params can be re-used by placing them in a shared `ExUnit` `Case` module.

```elixir
defmodule TestingEcto.FirstSchemaCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      alias Ecto.Changeset
      import TestingEcto.SchemaCase
    end
  end

  setup _ do
    Ecto.Adapters.SQL.Sandbox.mode(TestingEcto.Repo, :manual)
  end

  def valid_params(fields_with_types) do
    valid_value_by_type = %{
      date: fn -> to_string(Faker.Date.date_of_birth()) end,
      float: fn -> :rand.uniform() * 10 end,
      string: fn -> Faker.Lorem.word() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), valid_value_by_type[type].()}
    end
  end

  def invalid_params(fields_with_types) do
    invalid_value_by_type = %{
      date: fn -> Faker.Lorem.word() end,
      float: fn -> Faker.Lorem.word() end,
      string: fn -> DateTime.utc_now() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), invalid_value_by_type[type].()}
    end
  end
end
```

### Using `TestingEcto.SchemaCase` in a test module

```elixir
defmodule TestingEcto.Schemas.UserBasicSchema3Test do
  use TestingEcto.FirstSchemaCase

  alias TestingEcto.Schemas.UserBasicSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]
  @optional [:favorite_number]

  describe "fields and types" do
    @tag :schema_definition
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserBasicSchema.__schema__(:fields) do
          type = UserBasicSchema.__schema__(:type, field)
          {field, type}
        end

      assert Enum.sort(actual_fields_with_types) ==
               Enum.sort(@expected_fields_with_types)
    end
  end

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      valid_params = valid_params(@expected_fields_with_types)

      changeset = UserBasicSchema.changeset(valid_params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for {field, _} <- @expected_fields_with_types, field not in mutated do
        actual = Map.get(changes, field)
        expected = valid_params[Atom.to_string(field)]

        assert actual == expected,
               "Values did not match for field: #{field}\nexpected: #{inspect(expected)}\nactual: #{inspect(actual)}"
      end

      expected_dob = Date.from_iso8601!(valid_params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end

    test "error: returns an error changeset when given un-castable values" do
      invalid_params = invalid_params(@expected_fields_with_types)

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(invalid_params)

      for {field, _} <- @expected_fields_with_types do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end

    test "error: returns error changeset when required fields are missing" do
      params = %{}

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(params)

      for {field, _} <- @expected_fields_with_types, field not in @optional do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :required,
               "The validation type, #{meta[:validation]}, is incorrect."
      end

      for {field, _} <- @optional do
        refute errors[field],
               "The optional field #{field} is required when it shouldn't be."
      end
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Testing an Ecto Schema as a Data Validator

### Ecto Schema can be used to build validators for incoming data

* If data are valid, return an `:ok` tuple with a struct built from the input
* If data are invalid, return an `:error` tuple with the changeset

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule TestingEcto.Schemas.UserValidator do
  use Ecto.Schema
  import Ecto.Changeset

  @optional_fields [:favorite_number]

  @primary_key false
  embedded_schema do
    field(:date_of_birth, :date)
    field(:email, :string)
    field(:favorite_number, :float)
    field(:first_name, :string)
    field(:last_name, :string)
    field(:phone_number, :string)
  end

  defp all_fields do
    __MODULE__.__schema__(:fields)
  end

  def cast_and_validate(params) do
    %__MODULE__{}
    |> cast(params, all_fields())
    |> validate_required(all_fields() -- @optional_fields)
    |> apply_changes_if_valid()
  end

  defp apply_changes_if_valid(%Ecto.Changeset{valid?: true} = changeset) do
    {:ok, Ecto.Changeset.apply_changes(changeset)}
  end

  defp apply_changes_if_valid(%Ecto.Changeset{} = changeset) do
    {:error, changeset}
  end
end

```

<!-- livebook:{"break_markdown":true} -->

### Testing the validator

```elixir
defmodule TestingEcto.Schemas.UserValidatorTest do
  use TestingEcto.FirstSchemaCase

  alias TestingEcto.Schemas.UserValidator

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  @optional [:favorite_number]

  describe "fields and types" do
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserValidator.__schema__(:fields) do
          type = UserValidator.__schema__(:type, field)
          {field, type}
        end

      assert Enum.sort(actual_fields_with_types) ==
               Enum.sort(@expected_fields_with_types)
    end
  end

  describe "cast_and_validate/1" do
    test "success: returns a valid changeset when given valid arguments" do
      valid_params = valid_params(@expected_fields_with_types)

      {:ok, result} = UserValidator.cast_and_validate(valid_params)
      assert %UserValidator{} = result
      mutated = [:date_of_birth]

      for {field, _} <- @expected_fields_with_types, field not in mutated do
        assert Map.get(result, field) == valid_params[Atom.to_string(field)]
      end

      expected_dob = Date.from_iso8601!(valid_params["date_of_birth"])
      assert result.date_of_birth == expected_dob
    end

    test "error: returns an error changeset when given un-castable values" do
      invalid_params = invalid_params(@expected_fields_with_types)

      assert {:error, %Changeset{errors: errors}} =
               UserValidator.cast_and_validate(invalid_params)

      for {field, _} <- @expected_fields_with_types do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end

    test "error: returns error changeset when required fields are missing" do
      params = %{}

      assert {:error, %Changeset{errors: errors}} =
               UserValidator.cast_and_validate(params)

      for {field, _} <- @expected_fields_with_types, field not in @optional do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :required,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Testing an Ecto Schema for Database Interactions

### Sample module updated to be backed by a database

* adds database specific fields (an id and timestamps)
* no longer uses an embedded schema

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule TestingEcto.Schemas.UserDatabaseSchema do
  use Ecto.Schema
  import Ecto.Changeset

  @timestamps_opts type: :utc_datetime_usec
  @primary_key {:id, :binary_id, autogenerate: true}
  @optional_fields [:id, :favorite_number]

  schema "users" do
    field(:date_of_birth, :date)
    field(:email, :string)
    field(:favorite_number, :float)
    field(:first_name, :string)
    field(:last_name, :string)
    field(:phone_number, :string)

    timestamps()
  end

  defp all_fields do
    __MODULE__.__schema__(:fields)
  end

  def changeset(params) do
    %__MODULE__{}
    |> cast(params, all_fields())
    |> validate_required(all_fields() -- @optional_fields)
    |> unique_constraint(:email)
  end
end

```

<!-- livebook:{"break_markdown":true} -->

### Testing the new module

What's going to fail here?

```elixir
defmodule TestingEcto.Schemas.UserDatabaseSchemaFieldsAndTypesTest do
  use TestingEcto.SchemaCase

  alias TestingEcto.Schemas.UserDatabaseSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "fields and types" do
    @tag :schema_definition
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserDatabaseSchema.__schema__(:fields) do
          type = UserDatabaseSchema.__schema__(:type, field)
          {field, type}
        end

      assert Enum.sort(actual_fields_with_types) ==
               Enum.sort(@expected_fields_with_types)
    end
  end
end

ExUnit.run()
```

### Adding the new fields in the test

```elixir
defmodule TestingEcto.Schemas.UserDatabaseSchemaFieldsAndTypesWithNewFieldsTest do
  use TestingEcto.SchemaCase

  alias TestingEcto.Schemas.UserDatabaseSchema

  @expected_fields_with_types [
    {:id, :binary_id},
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:inserted_at, :utc_datetime_usec},
    {:last_name, :string},
    {:phone_number, :string},
    {:updated_at, :utc_datetime_usec}
  ]

  describe "fields and types" do
    @tag :schema_definition
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserDatabaseSchema.__schema__(:fields) do
          type = UserDatabaseSchema.__schema__(:type, field)
          {field, type}
        end

      assert Enum.sort(actual_fields_with_types) ==
               Enum.sort(@expected_fields_with_types)
    end
  end
end

ExUnit.run()
```

### Updating the `Case` module's helper functions

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule TestingEcto.SchemaCase do
  use ExUnit.CaseTemplate

  using do
    quote do
      alias Ecto.Changeset
      import TestingEcto.SchemaCase
    end
  end

  setup _ do
    Ecto.Adapters.SQL.Sandbox.mode(TestingEcto.Repo, :manual)
  end

  def valid_params(fields_with_types) do
    valid_value_by_type = %{
      date: fn -> to_string(Faker.Date.date_of_birth()) end,
      float: fn -> :rand.uniform() * 10 end,
      string: fn -> Faker.Lorem.word() end,
      # generate data for timestamps
      utc_datetime_usec: fn -> DateTime.utc_now() end,
      # generate data for id field
      binary_id: fn -> Ecto.UUID.generate() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), valid_value_by_type[type].()}
    end
  end

  def invalid_params(fields_with_types) do
    invalid_value_by_type = %{
      date: fn -> Faker.Lorem.word() end,
      float: fn -> Faker.Lorem.word() end,
      string: fn -> DateTime.utc_now() end,
      # generate data for timestamps
      utc_datetime_usec: fn -> Faker.Lorem.word() end,
      # generate data for id field
      binary_id: fn -> 1 end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), invalid_value_by_type[type].()}
    end
  end
end

```

<!-- livebook:{"break_markdown":true} -->

### Testing the `changeset/1` function

```elixir
defmodule TestingEcto.Schemas.UserDatabaseSchemaChangesetTest do
  use TestingEcto.SchemaCase

  alias TestingEcto.Schemas.UserDatabaseSchema

  @expected_fields_with_types [
    {:id, :binary_id},
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:inserted_at, :utc_datetime_usec},
    {:last_name, :string},
    {:phone_number, :string},
    {:updated_at, :utc_datetime_usec}
  ]

  @optional [:id, :favorite_number]

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      valid_params = valid_params(@expected_fields_with_types)

      changeset = UserDatabaseSchema.changeset(valid_params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for {field, _} <- @expected_fields_with_types, field not in mutated do
        assert Map.get(changes, field) == valid_params[Atom.to_string(field)]
      end

      expected_dob = Date.from_iso8601!(valid_params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end

    test "error: returns an error changeset when given un-castable values" do
      invalid_params = invalid_params(@expected_fields_with_types)

      assert %Changeset{valid?: false, errors: errors} =
               UserDatabaseSchema.changeset(invalid_params)

      for {field, _} <- @expected_fields_with_types do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end

    test "error: returns error changeset when required fields are missing" do
      params = %{}

      assert %Changeset{valid?: false, errors: errors} =
               UserDatabaseSchema.changeset(params)

      for {field, _} <- @expected_fields_with_types, field not in @optional do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :required,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end

    test "error: returns error changeset when an email address is reused" do
      Ecto.Adapters.SQL.Sandbox.checkout(TestingEcto.Repo)

      {:ok, existing_user} =
        valid_params(@expected_fields_with_types)
        |> UserDatabaseSchema.changeset()
        |> TestingEcto.Repo.insert()

      changeset_with_repeated_email =
        valid_params(@expected_fields_with_types)
        |> Map.put("email", existing_user.email)
        |> UserDatabaseSchema.changeset()

      assert {:error, %Changeset{valid?: false, errors: errors}} =
               TestingEcto.Repo.insert(changeset_with_repeated_email)

      assert errors[:email], "The field :email is missing from errors."
      {_, meta} = errors[:email]

      assert meta[:constraint] == :unique,
             "The validation type, #{meta[:validation]}, is incorrect."
    end
  end
end

ExUnit.run()
```

### Testing constraints

```elixir
defmodule TestingEcto.Schemas.UserDatabaseSchemaChangesetUniqueConstraintTest do
  use TestingEcto.SchemaCase

  alias TestingEcto.Schemas.UserDatabaseSchema

  @expected_fields_with_types [
    {:id, :binary_id},
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:inserted_at, :utc_datetime_usec},
    {:last_name, :string},
    {:phone_number, :string},
    {:updated_at, :utc_datetime_usec}
  ]

  describe "changeset/1" do
    test "error: returns error changeset when an email address is reused" do
      Ecto.Adapters.SQL.Sandbox.checkout(TestingEcto.Repo)

      {:ok, existing_user} =
        valid_params(@expected_fields_with_types)
        |> UserDatabaseSchema.changeset()
        |> TestingEcto.Repo.insert()

      changeset_with_repeated_email =
        valid_params(@expected_fields_with_types)
        |> Map.put("email", existing_user.email)
        |> UserDatabaseSchema.changeset()

      assert {:error, %Changeset{valid?: false, errors: errors}} =
               TestingEcto.Repo.insert(changeset_with_repeated_email)

      assert errors[:email], "The field :email is missing from errors."
      {_, meta} = errors[:email]

      assert meta[:constraint] == :unique,
             "The validation type, #{meta[:validation]}, is incorrect."
    end
  end
end

ExUnit.run()
```
