# Testing Ecto Schema

```elixir
Mix.install(
  [
    {:testing_ecto, path: Path.join(__DIR__, "."), env: :dev}
  ],
  config_path: :testing_ecto,
  lockfile: :testing_ecto
)
```

## Introduction

### What to test

Don't test the framework.

Test that your code uses the framework correctly.

Heuristic: you _should not_ test that a function in Ecto works correctly, but you should test that it is _called_ correctly.

## Testing Your Schema Through Changesets

### A sample module for testing

* Uses an embedded schema because we aren't yet testing the database
* Uses reflection in the `all_fields/0` function to get a list of fields for casting

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule TestingEcto.Schemas.UserBasicSchema do
  use Ecto.Schema

  import Ecto.Changeset

  @optional_fields [:favorite_number]

  @primary_key false
  embedded_schema do
    field(:date_of_birth, :date)
    field(:email, :string)
    field(:favorite_number, :float)
    field(:first_name, :string)
    field(:last_name, :string)
    field(:phone_number, :string)
  end

  defp all_fields do
    __MODULE__.__schema__(:fields)
  end

  def changeset(params) do
    %__MODULE__{}
    |> cast(params, all_fields())
    |> validate_required(all_fields() -- @optional_fields)
  end
end
```

#### Sample tests

Some tests that test if we are using Ecto Schema correctly

1. The presence of fields in a schema
2. Casting input
3. Validating input

## Start ExUnit

```elixir
ExUnit.start(autorun: false)
```

<!-- livebook:{"branch_parent_index":2} -->

## Happy path with valid arguments

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidArgumentsTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      params = %{
        "date_of_birth" => "1948-02-28",
        "email" => "example@example.com",
        "favorite_number" => 3.14,
        "first_name" => "Bob",
        "last_name" => "Matthews",
        "phone_number" => "555-555-5555"
      }

      changeset = UserBasicSchema.changeset(params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for field <- @schema_fields, field not in mutated do
        actual = Map.get(changes, field)
        expected = params[Atom.to_string(field)]

        assert actual == expected,
               "Values did not match for field: #{field}\nexpected: #{inspect(expected)}\nactual: #{inspect(actual)}"
      end

      expected_dob = Date.from_iso8601!(params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end
  end
end

ExUnit.run()
```

## Testing casting

#### Avoid brittle tests

A test that checked to see **how many errors** are generated would be brittle.

A test that checks to make sure you get the **right kind of error** would not be brittle.

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaCastingTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "error: returns an error changeset when given un-castable values" do
      not_a_string = DateTime.utc_now()

      # invalid params for each field
      params = %{
        "date_of_birth" => "not a date",
        "email" => not_a_string,
        "favorite_number" => "not a number",
        "first_name" => not_a_string,
        "last_name" => not_a_string,
        "phone_number" => not_a_string
      }

      changeset = UserBasicSchema.changeset(params)

      assert %Changeset{valid?: false, errors: errors} = changeset

      for field <- @schema_fields do
        assert errors[field], "expected an error for #{field}"
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end
  end
end

ExUnit.run()
```

## Testing schema validation

An example of a useful test for validation would be a test that checks to make sure that required fields are included.

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidateRequiredFieldsTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @schema_fields [
    :date_of_birth,
    :email,
    :favorite_number,
    :first_name,
    :last_name,
    :phone_number
  ]

  describe "changeset/1" do
    test "error: returns error changeset when required fields are missing" do
      # Empty map to force violation of the validation for required fields
      # A nil or empty string would also fail validation for a required field
      params = %{}

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(params)

      optional_params = [:favorite_number]
      expected_fields = @schema_fields -- optional_params

      for field <- expected_fields do
        assert errors[field], "Field #{inspect(field)} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :required,
               "The validation type, #{meta[:validation]}, is incorrect."
      end

      for field <- optional_params do
        refute errors[field],
               "The optional field #{field} is required when it shouldn't be."
      end
    end
  end
end

ExUnit.run()
```

<!-- livebook:{"branch_parent_index":2} -->

## Refactoring to Increase Test Maintainability

Refactoring tests to be "self-updating"

Goes through several steps to improve test maintainability

1. Validating field types in a schema
2. Adding helper functions to generate valid and invalid data

## Tests for validating types in a schema

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidatingFieldTypesTest do
  use ExUnit.Case

  alias TestingEcto.Schemas.UserBasicSchema

  # Adds tuples that allow testing of fields and their types
  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "fields and types" do
    @tag :schema_definition
    test "it has the correct fields and types" do
      actual_fields_with_types =
        for field <- UserBasicSchema.__schema__(:fields) do
          type = UserBasicSchema.__schema__(:type, field)
          {field, type}
        end

      assert MapSet.new(actual_fields_with_types) ==
               MapSet.new(@expected_fields_with_types)
    end
  end
end

ExUnit.run()
```

## Generating data in a test

Adding a helper function to generate valid data for fields testing

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaValidParamsHelperTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "changeset/1" do
    test "success: returns a valid changeset when given valid arguments" do
      valid_params = valid_params(@expected_fields_with_types)

      changeset = UserBasicSchema.changeset(valid_params)
      assert %Changeset{valid?: true, changes: changes} = changeset

      mutated = [:date_of_birth]

      for {field, _} <- @expected_fields_with_types, field not in mutated do
        actual = Map.get(changes, field)
        expected = valid_params[Atom.to_string(field)]

        assert actual == expected,
               "Values did not match for field: #{field}\nexpected: #{inspect(expected)}\nactual: #{inspect(actual)}"
      end

      expected_dob = Date.from_iso8601!(valid_params["date_of_birth"])
      assert changes.date_of_birth == expected_dob
    end
  end

  defp valid_params(fields_with_types) do
    valid_value_by_type = %{
      date: fn -> to_string(Faker.Date.date_of_birth()) end,
      float: fn -> :rand.uniform() * 10 end,
      string: fn -> Faker.Lorem.word() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), valid_value_by_type[type].()}
    end
  end
end

ExUnit.run()
```

## Testing Invalid Params

Adding a helper function to generate invalid data for fields testing

```elixir
defmodule TestingEcto.Schemas.UserBasicSchemaInvalidParamsHelperTest do
  use ExUnit.Case

  alias Ecto.Changeset
  alias TestingEcto.Schemas.UserBasicSchema

  @expected_fields_with_types [
    {:date_of_birth, :date},
    {:email, :string},
    {:favorite_number, :float},
    {:first_name, :string},
    {:last_name, :string},
    {:phone_number, :string}
  ]

  describe "changeset/1" do
    test "error: returns an error changeset when given un-castable values" do
      invalid_params = invalid_params(@expected_fields_with_types)

      assert %Changeset{valid?: false, errors: errors} =
               UserBasicSchema.changeset(invalid_params)

      for {field, _} <- @expected_fields_with_types do
        assert errors[field], "The field :#{field} is missing from errors."
        {_, meta} = errors[field]

        assert meta[:validation] == :cast,
               "The validation type, #{meta[:validation]}, is incorrect."
      end
    end
  end

  defp invalid_params(fields_with_types) do
    invalid_value_by_type = %{
      date: fn -> Faker.Lorem.word() end,
      float: fn -> Faker.Lorem.word() end,
      string: fn -> DateTime.utc_now() end
    }

    for {field, type} <- fields_with_types, into: %{} do
      {Atom.to_string(field), invalid_value_by_type[type].()}
    end
  end
end

ExUnit.run()
```
